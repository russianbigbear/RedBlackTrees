## Красно-чёрные деревья.

### Задание
Создано два КЧД. Пополнить большее по всу дерево той записью другого дерева, ключ которой имеет минимальное значение из тех ключей,
которые не содержатся в пополняемом дереве.
### Алгоритм
Из файлов f1.txt и f2.txt мы считываем данные по первому и второму дереву.<br/>
При каждом считывания ключа элемента мы сохраняем его в вектор ключей дерева и вставляем его в дерево, тем самым формируем его. Вставка элемента в дереве описана ниже.<br/>
<br/>
**Вставка** – Находим вершину, начиная обход от корня дерева, которая должна стать родительской для новой вершины. Новая вершина,
содержащая добавляемый элемент множества, становится левым или правым сыном найденной вершины в зависимости от величины добавляемого элемента в сравнении с элементом в родительской вершине.
Если добавляемый элемент больше родительского, то он становится правым сыном иначе левым. <br/>
<br/>
Элемент добавлен, теперь применим балансировку, чтобы добиться восстановления свойств КЧД.
Новая вершина (она в рассмотренном алгоритме всегда является терминальной) окрашивается в красный цвет.
Если родительская вершина для добавленной имеет черный цвет, то все свойства красно-черного дерева при этом сохраняются,
и никаких дополнительных действий не требуется. Однако, если родительская вершина красная, то нарушается требование того,
что дети красной вершины должны быть черными, и нужно выполнить процедуру восстановления структуры красно-черного дерева.<br/>
<br/>
**Восстановление структуры красно-черного дерева после добавления вершины (ребалансировка)**<br/>
При добавлении вершины в дереве поиска новая вершина добавляется как терминальная.
В красно-черном дереве новая вершина окрашивается изначально в красный цвет.
Если ее родительская вершина черная, то все свойства красно-черного дерева выполняются и алгоритм добавления на этом заканчивается.
Если же родительская вершина красная, то нарушается второе свойство в определении красно-черного дерева: у красной вершины дети должны быть черными.
В этом случае выполняется процедура ребалансировки (восстановления структуры красно-черного дерева). 
Процедура ребалансировки носит итеративный характер. В ней рассматривается текущий узел Х красного цвета, родительский узел (отец) которого тоже красный.<br/>
<br/>
**Для ребалансировки выполняются след действия:**
* перекрашивание вершин дерева (восстановление цвета),
* вращение вершины дерева влево или вправо.
<br/>
После того, как мы сформировали два дерева, мы проверяем сколько элементов содержится в каждом дереве. 
Если не ноль, то создаем 2 файла JPG, графическое отображение 1-ого и 2-ого дерева.
Если второе дерево не содержит элементов, то создаем 2 файла JPG, графическое отображение 1-ого и результирующего дерева. дерева (это первое дерево, так как нечего добавлять из 2-ого). Выходим из программы.
Если первое дерево не содержит элементов, то создаем 2 файла JPG, графическое отображение 2-ого и результирующего дерева (это второе дерево, так как нечего добавлять из 1-ого). Выходим из программы.
Если оба дерева не содержат элементов, то выдает сообщение и выходим.<br/>
<br/>
Только при одном варианте мы остаемся и продолжаем работы. Мы вызываем функцию, в которую передаем первым аргументом вектор с ключами большего дерева,
а вторым вектор меньшего дерева. И в этой функции мы удаляем из вектора меньшего дерева элементы, содержащиеся в векторе большего дерева. 
Сортируем второй вектор и возвращаем первый элемент второго вектора(наименьший). Этот элемент вставляем в наибольшее дерево, и после формируем 3 JPG,
с результирующим деревом.<br/>
<br/>
По удачном выполнении программы, имеем 3 файла JPG с нарисованными деревьями.
Использованы возможности graphviz.<br/>
